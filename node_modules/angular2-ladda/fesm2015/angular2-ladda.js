import { Injectable, Directive, ElementRef, Inject, Optional, Input, NgModule } from '@angular/core';
import { create } from 'ladda';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class LaddaConfigArgs {
}
/** @type {?} */
let configAttributes = {
    "data-style": "style",
    "data-spinner-size": "spinnerSize",
    "data-spinner-color": "spinnerColor",
    "data-spinner-lines": "spinnerLines",
};
class LaddaConfig {
    /**
     * @param {?=} config
     */
    constructor(config = {}) {
        Object.assign(this, config);
    }
}
LaddaConfig.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LaddaConfig.ctorParameters = () => [
    { type: LaddaConfigArgs }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LaddaDirective {
    /**
     * @param {?} el
     * @param {?} config
     */
    constructor(el, config) {
        this.el = el.nativeElement;
        if (!config) {
            return;
        }
        // apply default styles if they aren't overwritten by an attribute
        for (let attribute in configAttributes) {
            /** @type {?} */
            let configValue = config[configAttributes[attribute]];
            if (!configValue) {
                continue; // don't waste time reading the attribute
            }
            if (!this.el.getAttribute(attribute)) {
                // attribute isn't set - apply the default config value
                /** @type {?} */
                let value = (typeof configValue === "number") ? configValue.toString() : configValue;
                this.el.setAttribute(attribute, value);
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.ladda) {
            return; // needed since ngOnChanges is called before ngOnInit
        }
        if (changes.loading) {
            this.updateLadda(changes.loading.previousValue);
        }
        if (changes.disabled) {
            this.updateDisabled();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ladda = create(this.el);
        // if the initial loading value isn't false, a timeout of 0 ms
        // is necessary for the calculated spinner size to be correct.
        setTimeout((/**
         * @return {?}
         */
        () => { this.updateLadda(false); }), 0);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.ladda) {
            this.ladda.remove();
        }
    }
    /**
     * @private
     * @param {?} previousValue
     * @return {?}
     */
    updateLadda(previousValue) {
        /** @type {?} */
        let loading = typeof this.loading === 'number' || !!this.loading;
        /** @type {?} */
        let wasLoading = typeof previousValue === 'number' || !!previousValue;
        if (!loading) {
            if (wasLoading) {
                this.ladda.stop();
            }
            return this.updateDisabled();
        }
        if (!wasLoading) {
            this.ladda.start();
        }
        if (typeof this.loading === 'number') {
            this.ladda.setProgress(this.loading);
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateDisabled() {
        this.el.disabled = this.disabled;
    }
}
LaddaDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ladda]'
            },] }
];
/** @nocollapse */
LaddaDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: LaddaConfigArgs, decorators: [{ type: Inject, args: [LaddaConfig,] }, { type: Optional }] }
];
LaddaDirective.propDecorators = {
    loading: [{ type: Input, args: ['ladda',] }],
    disabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LaddaModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: LaddaModule,
            providers: [
                { provide: LaddaConfig, useValue: config }
            ]
        };
    }
}
LaddaModule.decorators = [
    { type: NgModule, args: [{
                declarations: [LaddaDirective],
                exports: [LaddaDirective],
            },] }
];

export { LaddaConfig, LaddaConfigArgs, LaddaDirective, LaddaModule, configAttributes };
//# sourceMappingURL=angular2-ladda.js.map

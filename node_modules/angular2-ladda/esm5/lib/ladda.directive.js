/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Input, Optional, Inject } from '@angular/core';
import { LaddaConfig, LaddaConfigArgs, configAttributes } from './ladda-config';
import { create as createLadda } from 'ladda';
var LaddaDirective = /** @class */ (function () {
    function LaddaDirective(el, config) {
        this.el = el.nativeElement;
        if (!config) {
            return;
        }
        // apply default styles if they aren't overwritten by an attribute
        for (var attribute in configAttributes) {
            /** @type {?} */
            var configValue = config[configAttributes[attribute]];
            if (!configValue) {
                continue; // don't waste time reading the attribute
            }
            if (!this.el.getAttribute(attribute)) {
                // attribute isn't set - apply the default config value
                /** @type {?} */
                var value = (typeof configValue === "number") ? configValue.toString() : configValue;
                this.el.setAttribute(attribute, value);
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    LaddaDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.ladda) {
            return; // needed since ngOnChanges is called before ngOnInit
        }
        if (changes.loading) {
            this.updateLadda(changes.loading.previousValue);
        }
        if (changes.disabled) {
            this.updateDisabled();
        }
    };
    /**
     * @return {?}
     */
    LaddaDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.ladda = createLadda(this.el);
        // if the initial loading value isn't false, a timeout of 0 ms
        // is necessary for the calculated spinner size to be correct.
        setTimeout((/**
         * @return {?}
         */
        function () { _this.updateLadda(false); }), 0);
    };
    /**
     * @return {?}
     */
    LaddaDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.ladda) {
            this.ladda.remove();
        }
    };
    /**
     * @private
     * @param {?} previousValue
     * @return {?}
     */
    LaddaDirective.prototype.updateLadda = /**
     * @private
     * @param {?} previousValue
     * @return {?}
     */
    function (previousValue) {
        /** @type {?} */
        var loading = typeof this.loading === 'number' || !!this.loading;
        /** @type {?} */
        var wasLoading = typeof previousValue === 'number' || !!previousValue;
        if (!loading) {
            if (wasLoading) {
                this.ladda.stop();
            }
            return this.updateDisabled();
        }
        if (!wasLoading) {
            this.ladda.start();
        }
        if (typeof this.loading === 'number') {
            this.ladda.setProgress(this.loading);
        }
    };
    /**
     * @private
     * @return {?}
     */
    LaddaDirective.prototype.updateDisabled = /**
     * @private
     * @return {?}
     */
    function () {
        this.el.disabled = this.disabled;
    };
    LaddaDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ladda]'
                },] }
    ];
    /** @nocollapse */
    LaddaDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: LaddaConfigArgs, decorators: [{ type: Inject, args: [LaddaConfig,] }, { type: Optional }] }
    ]; };
    LaddaDirective.propDecorators = {
        loading: [{ type: Input, args: ['ladda',] }],
        disabled: [{ type: Input }]
    };
    return LaddaDirective;
}());
export { LaddaDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    LaddaDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    LaddaDirective.prototype.ladda;
    /** @type {?} */
    LaddaDirective.prototype.loading;
    /** @type {?} */
    LaddaDirective.prototype.disabled;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFkZGEuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhcjItbGFkZGEvIiwic291cmNlcyI6WyJsaWIvbGFkZGEuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQStDLFFBQVEsRUFBRSxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDMUgsT0FBTyxFQUFDLFdBQVcsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5RSxPQUFPLEVBQUMsTUFBTSxJQUFJLFdBQVcsRUFBYyxNQUFNLE9BQU8sQ0FBQztBQUl6RDtJQVVJLHdCQUFZLEVBQWMsRUFBbUMsTUFBdUI7UUFDaEYsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDO1FBRTNCLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDVCxPQUFPO1NBQ1Y7UUFFRCxrRUFBa0U7UUFDbEUsS0FBSyxJQUFJLFNBQVMsSUFBSSxnQkFBZ0IsRUFBRTs7Z0JBQ2hDLFdBQVcsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7WUFFckQsSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDZCxTQUFTLENBQUMseUNBQXlDO2FBQ3REO1lBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxFQUFFOzs7b0JBRTlCLEtBQUssR0FBRyxDQUFDLE9BQU8sV0FBVyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVc7Z0JBQ3BGLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQzthQUMxQztTQUNKO0lBQ0wsQ0FBQzs7Ozs7SUFFRCxvQ0FBVzs7OztJQUFYLFVBQVksT0FBc0I7UUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDYixPQUFPLENBQUMscURBQXFEO1NBQ2hFO1FBRUQsSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFO1lBQ2pCLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUNuRDtRQUVELElBQUksT0FBTyxDQUFDLFFBQVEsRUFBRTtZQUNsQixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7U0FDekI7SUFDTCxDQUFDOzs7O0lBRUQsaUNBQVE7OztJQUFSO1FBQUEsaUJBTUM7UUFMRyxJQUFJLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFbEMsOERBQThEO1FBQzlELDhEQUE4RDtRQUM5RCxVQUFVOzs7UUFBQyxjQUFRLEtBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdEQsQ0FBQzs7OztJQUVELG9DQUFXOzs7SUFBWDtRQUNJLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNaLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDdkI7SUFDTCxDQUFDOzs7Ozs7SUFFTyxvQ0FBVzs7Ozs7SUFBbkIsVUFBb0IsYUFBeUI7O1lBQ3JDLE9BQU8sR0FBWSxPQUFPLElBQUksQ0FBQyxPQUFPLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTzs7WUFDckUsVUFBVSxHQUFZLE9BQU8sYUFBYSxLQUFLLFFBQVEsSUFBSSxDQUFDLENBQUMsYUFBYTtRQUU5RSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ1YsSUFBSSxVQUFVLEVBQUU7Z0JBQ1osSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUNyQjtZQUVELE9BQU8sSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNiLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDdEI7UUFFRCxJQUFJLE9BQU8sSUFBSSxDQUFDLE9BQU8sS0FBSyxRQUFRLEVBQUU7WUFDbEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3hDO0lBQ0wsQ0FBQzs7Ozs7SUFFTyx1Q0FBYzs7OztJQUF0QjtRQUNJLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDckMsQ0FBQzs7Z0JBcEZKLFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUsU0FBUztpQkFDdEI7Ozs7Z0JBUmtCLFVBQVU7Z0JBQ1IsZUFBZSx1QkFlSCxNQUFNLFNBQUMsV0FBVyxjQUFHLFFBQVE7OzswQkFIekQsS0FBSyxTQUFDLE9BQU87MkJBQ2IsS0FBSzs7SUE2RVYscUJBQUM7Q0FBQSxBQXJGRCxJQXFGQztTQWxGWSxjQUFjOzs7Ozs7SUFDdkIsNEJBQThCOzs7OztJQUM5QiwrQkFBMkI7O0lBRTNCLGlDQUFvQzs7SUFDcEMsa0NBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0LCBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLCBPcHRpb25hbCwgSW5qZWN0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtMYWRkYUNvbmZpZywgTGFkZGFDb25maWdBcmdzLCBjb25maWdBdHRyaWJ1dGVzfSBmcm9tICcuL2xhZGRhLWNvbmZpZyc7XHJcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZUxhZGRhLCBMYWRkYUJ1dHRvbn0gZnJvbSAnbGFkZGEnO1xyXG5cclxuZXhwb3J0IHR5cGUgbGFkZGFWYWx1ZSA9IGJvb2xlYW4gfCBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1tsYWRkYV0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBMYWRkYURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95LCBPbkNoYW5nZXMge1xyXG4gICAgcHJpdmF0ZSBlbDogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGxhZGRhOiBMYWRkYUJ1dHRvbjtcclxuXHJcbiAgICBASW5wdXQoJ2xhZGRhJykgbG9hZGluZzogbGFkZGFWYWx1ZTtcclxuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGVsOiBFbGVtZW50UmVmLCBASW5qZWN0KExhZGRhQ29uZmlnKSBAT3B0aW9uYWwoKSBjb25maWc6IExhZGRhQ29uZmlnQXJncykge1xyXG4gICAgICAgIHRoaXMuZWwgPSBlbC5uYXRpdmVFbGVtZW50O1xyXG5cclxuICAgICAgICBpZiAoIWNvbmZpZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSBkZWZhdWx0IHN0eWxlcyBpZiB0aGV5IGFyZW4ndCBvdmVyd3JpdHRlbiBieSBhbiBhdHRyaWJ1dGVcclxuICAgICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gY29uZmlnQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICBsZXQgY29uZmlnVmFsdWUgPSBjb25maWdbY29uZmlnQXR0cmlidXRlc1thdHRyaWJ1dGVdXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghY29uZmlnVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBkb24ndCB3YXN0ZSB0aW1lIHJlYWRpbmcgdGhlIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZWwuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBpc24ndCBzZXQgLSBhcHBseSB0aGUgZGVmYXVsdCBjb25maWcgdmFsdWVcclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9ICh0eXBlb2YgY29uZmlnVmFsdWUgPT09IFwibnVtYmVyXCIpID8gY29uZmlnVmFsdWUudG9TdHJpbmcoKSA6IGNvbmZpZ1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgICAgIGlmICghdGhpcy5sYWRkYSkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIG5lZWRlZCBzaW5jZSBuZ09uQ2hhbmdlcyBpcyBjYWxsZWQgYmVmb3JlIG5nT25Jbml0XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2hhbmdlcy5sb2FkaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGFkZGEoY2hhbmdlcy5sb2FkaW5nLnByZXZpb3VzVmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoYW5nZXMuZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVEaXNhYmxlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLmxhZGRhID0gY3JlYXRlTGFkZGEodGhpcy5lbCk7XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSBpbml0aWFsIGxvYWRpbmcgdmFsdWUgaXNuJ3QgZmFsc2UsIGEgdGltZW91dCBvZiAwIG1zXHJcbiAgICAgICAgLy8gaXMgbmVjZXNzYXJ5IGZvciB0aGUgY2FsY3VsYXRlZCBzcGlubmVyIHNpemUgdG8gYmUgY29ycmVjdC5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy51cGRhdGVMYWRkYShmYWxzZSk7IH0sIDApO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhZGRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFkZGEucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdXBkYXRlTGFkZGEocHJldmlvdXNWYWx1ZTogbGFkZGFWYWx1ZSk6IHZvaWQge1xyXG4gICAgICAgIGxldCBsb2FkaW5nOiBib29sZWFuID0gdHlwZW9mIHRoaXMubG9hZGluZyA9PT0gJ251bWJlcicgfHwgISF0aGlzLmxvYWRpbmc7XHJcbiAgICAgICAgbGV0IHdhc0xvYWRpbmc6IGJvb2xlYW4gPSB0eXBlb2YgcHJldmlvdXNWYWx1ZSA9PT0gJ251bWJlcicgfHwgISFwcmV2aW91c1ZhbHVlO1xyXG5cclxuICAgICAgICBpZiAoIWxvYWRpbmcpIHtcclxuICAgICAgICAgICAgaWYgKHdhc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFkZGEuc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVEaXNhYmxlZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF3YXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFkZGEuc3RhcnQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sb2FkaW5nID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLmxhZGRhLnNldFByb2dyZXNzKHRoaXMubG9hZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdXBkYXRlRGlzYWJsZWQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5lbC5kaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQ7XHJcbiAgICB9XHJcbn1cclxuIl19